计算机安全  
====

我们知道了了计算机如何互连, 让我们能瞬时跨全球沟通  
* 但不是每个使用网络的人都会规规矩矩, 不损害他人利益   
* 就像现实世界中我们用锁和栅栏保证物理安全, 有警察减少犯罪  
我们需要网络安全减少虚拟世界中的犯罪  
计算机没有道德观念  
* 只要给计算机写清具体问题,  它们很乐意地闪电般算出答案  
* 破坏医院计算机系统和保持病人心跳的程序 


计算机安全的范围, 和计算能力的发展速度一样快  
我们可以把计算机安全，看成是保护系统和数据的:   
### 保密性、完整性和可用性
> "保密性"是只有有权限的人, 才能读取计算机系统和数据
>> 黑客泄露别人的信用卡信息，就是攻击保密性.
> 
> "完整性"是只有有权限的人, 才能使用和修改系统和数据
>> 黑客知道你的邮箱密码，假冒你发邮件, 就是攻击"完整性"
> 
> "可用性"是有权限的人，应该随时可以访问系统和数据  
>> 拒绝服务攻击(DDOS) 就是黑客  
>> 发大量的假请求到服务器，让网站很慢或者挂掉  
>> 这就是攻击"可用性"


## 分析攻击目标  
安全专家会从抽象层面想象"敌人"可能是谁，这叫"威胁模型分析"   
模型会对攻击者有个大致描述:  
1、能力如何  
2、目标可能是什么  
3、可能用什么手段  
> 攻击手段又叫"攻击矢量  
> "威胁模型分析"让你能为特定情境做准备  
![2](https://github.com/KissMyLady/Computer/blob/master/Image/Works/sf-2.jpg)   

> 假设你想确保笔记本计算机的"物理安全", 
> 你的威胁模型是"好管闲事的室友"
>> 为了保证保密性，完整性和可用性, 你可以藏在脏兮兮的洗衣篮里  
> 
> 但如果威胁模型是调皮的兄弟姐妹, 知道你喜欢藏哪里  
>> 那么你需要更多保护: 比如锁在保险箱里  

换句话说, 要怎么保护, 具体看对抗谁  
当然, 威胁模型通常比"好管闲事的室友"更正式一些  


## 威胁模型级别区分
通常威胁模型分析里, 会以能力水平区分   
> 比如"某人可以物理接触到笔记本计算机，而且时间无限"  

在给定的威胁模型下，安全架构师要  
> 提供解决方案，保持系统安全
只要某些假设不被推翻
* 比如没人会告诉攻击者密码
保护计算机系统，网络和数据的方法有很多

### 你是谁？你能访问什么？
很多安全问题可以总结成2个问题：
* 你是谁？你能访问什么？
权限应该给合适的人，拒绝错误的人

![3](https://github.com/KissMyLady/Computer/blob/master/Image/Works/sf-3.jpg)  
#### 但我不应该有权限打开, 因为我会把钱拿走全拿走！

所以，为了区分谁是谁    
我们用"身份认证"(authentication)让计算机得知使用者是谁    
> 身份认证有三种，各有利弊：     
>> 你知道什么  
>> 你有什么 
>> 你是什么  

### "你知道什么"   
"你知道什么" 是基于某个秘密      
* 只有用户和计算机知道   
> ![4](https://github.com/KissMyLady/Computer/blob/master/Image/Works/sf-1.jpg)  
这是如今使用最广泛的，因为最容易实现   

但如果黑客通过猜测或其他方式，知道你的密码，就惨了 
有些密码很容易猜中，比如12356或qwerty(键盘起始6个固定键位)    


### 暴力攻击(全排列猜密码)     
但有些密码对计算机很容易   
比如PIN码：2580  
> 看起来很难猜中: 起码对人类来说是这样
> 但4位数字，只有一万种可能
> 一台计算机可以尝试0000，然后0001，然后0002，
> 然后到9999，不到一秒内试完  

这叫"暴力攻击"，因为只是试遍一切可能 
> 这种算法没什么聪明的地方  
> 如果你错误尝试3次, 有些系统会阻止你继续尝试，或让你等一会儿
> 这个策略普遍而且合理
对于一般的攻击者确实很难


### 僵尸网络  
但假设黑客控制了数以万计的计算机，形成一个僵尸网络    
> 用这么多计算机尝试密码2580   
> 同时尝试很多银行账户   
> 即使每个账户只试一次，也很可能的   


### 增加密码长度
增加密码长度有帮助  
但即使8位数字的PIN码也很容易破解
这就是为什么现在很多网站，要求大写+ 小写    
还有特殊符号等，大大增加可能的密码   
> 8位数字的PIN只有一亿种组合   
> 对计算机轻而易举   
>> 但包含各种字符的8位长度密码  
>> 有超过600万亿种组合  

当然，这些密码会难以记住，  
所以更好的方法是, 选一些更好记的东西    
比如三个单词连在一起：  
"green brothers rock" or "pizza tasty yum"   
英文大约有10万个单词,所以三个单词连一起大概有   
![5](https://github.com/KissMyLady/Computer/blob/master/Image/Works/sf-5.jpg)  
[量子计算机-李永乐老师油管讲解](https://www.youtube.com/watch?v=BzyOoo4AOxs)   
以后量子计算机出来，将会对人类产生深远的影响，
密码在量子计算机面前是无力的:  
暴力破解2^250次位的密码只需要1秒，而普通计算机要几万年   


### "你有什么"  
另外使用不在字典内的单词, 被猜中的可能性更低    
"你有什么"这种验证方式是基于用户有特定物体    
比如钥匙和锁    
如果你有钥匙，就能开门     
这避免了被人"猜中"的问题     
而且通常需要人在现场   
所以远程攻击就更难了      
生物识别验证器，比如指纹识别器和虹膜扫描仪就是典型例子   
这些非常安全，但最好的识别技术仍然很贵  
而且，来自传感器的数据每次会不同  
"你知道什么"和"你有什么"。这两种验证是"确定性"的  
* 要么正确，要么错误  
> 如果你知道密码，或有钥匙，那么100％能获得访问权限  
> 如果没有，就绝对进不去  
>> 但"生物识别"是概率性的，系统有可能认不出你  
>> 可能你戴了帽子，或者光线不好  
>> 更糟的是，系统可能把别人错认成你  
>> 比如你的邪恶双胞胎  
>> 当然，在现实世界中几率很低，但不是零  

### 缺 点:  
生物认证的另一个问题是无法重设  
> 你只有这么多手指，如果攻击者拿到你的指纹数据怎么办  
> 你一辈子都麻烦了  
>> 最近还有研究人员表示，拍个照都有可能伪造虹膜  
>> 所以也不靠谱  
  
## 双点认证   
所有认证方法都有优缺点, 它们都可以被攻破    
所以，对于重要账户, 安全专家建议用两种或两种以上的认证方式    
这叫"双因素"或"多因素"认证    
> 攻击者可能猜出你密码，或偷走你的手机：   
> 但两个都做到，会比较难  

### 执行权限    
"身份验证"后，就来到了"访问控制"  
* 一旦系统知道你是谁，它需要知道你能访问什么，  
因此应该有个规范，说明谁能访问什么，修改什么，使用什么。 
这可以通过"权限"或"访问控制列表"(ACL)来实现    
其中描述了用户对每个文件，文件夹和程序的访问权限  
> "读"权限: 允许用户查看文件内容      
> "写"权限: 允许用户修改内容     
> "执行"权限:允许用户运行文件，比如程序    

有些组织需要不同层级的权限  
比如间谍机构，"访问控制列表"的正确配置非常重要  
以确保保密性，完整性和可用性  
假设我们有三个访问级别：公开，机密，绝密  

### 不能向上"读"   
第一个普遍的好做法是，用户不能"读上", 不能读等级更高的信息   
如果用户能读"机密"文件, 那么不应该有权限读"绝密"文件  
但能访问"机密"和"公开"文件  

### 不能向下"写"  
第二个法则是用户不能"写下"  
如果用户等级是"绝密"  
那么能写入或修改"绝密"文件，但不能修改"机密"或"公共"文件  
* 听起来好像很奇怪，有最高等级也不能改等级更低的文件  
	* 但这样确保了"绝密"不会意外泄露到"机密"文件或"公共"文件里  

### Bell-LaPadula模型  
这个"不能向上读，不能向下写"的方法叫Bell-LaPadula模型    


"身份验证"和"访问控制"帮助计算机知道"你是谁"   
以及"你可以访问什么"，    
但做这些事情的软硬件必须是可信的  

这个依赖很重要    
如果攻击者给计算机装了恶意软件, 控制了计算机的操作系统     
我们怎么确定安全程序没有给攻击者留后门？    
回答是...无法确定    

 
我们仍然无法保证程序或计算机系统的安全  
因为安全软件在理论上可能是"安全的", 实现时可能会不小心留下漏洞      
但我们有办法减少漏洞出现的可能性 
> 比如一找到就马上修复  
> 以及当程序被攻破时尽可能减少损害  
大部分漏洞都是具体实现的时候出错了  
为了减少执行错误，减少执行  

## 安全审查  
系统级安全的圣杯之一是"安全内核"  
或"可信计算基础"：一组尽可能少的操作系统软件  
安全性都是接近可验证的   
构建安全内核的挑战在于 决定内核应该有什么       
* 记住，代码越少越好！  

在最小化代码数量之后，要是能"保证"代码是安全的，会非常棒      
正式验证代码的安全性 是一个活跃的研究领域      
我们现在最好的手段，叫"独立安全检查和质量验证"    
#### 让一群安全行业内的软件开发者来审计代码    
* 这就是为什么安全型代码几乎都是开源的     
* 写原始代码的人通常很难找到错误     
	* 但外部开发人员有新鲜的眼光，和不同领域的专业知识，可以发现问题   
	* 另外还有一些安全大会，安全专家可以相互认识，分享想法.   
![6](https://github.com/KissMyLady/Computer/blob/master/Image/Works/sf-6.jpg)  

## 隔  离  
> 最后，即便尽可能减少代码并进行了安全审计      
> 聪明的攻击者还是会找到方法入侵      
因为如此，优秀的开发人员      
应该计划当程序被攻破后，如何限制损害，控制损害的最大程度  
并且不让它危害到计算机上其他东西    
这叫"隔离"     
> 要实现隔离，我们可以"沙盒"程序   
> 这好比把生气的小孩放在沙箱里，  
> 他们只能摧毁自己的沙堡，不会影响到其他孩子  
  
> 操作系统会把程序放到沙盒里  
> 方法是给每个程序独有的内存块，其他程序不能动  
> 一台计算机可以运行多个虚拟机  
>> 虚拟机模拟计算机，每个虚拟机都在自己的沙箱里    
>> 如果一个程序出错，最糟糕的情况是它自己崩溃    
>> 或者搞坏它处于的虚拟机      
>> 计算机上其他虚拟机是隔离的，不受影响    

所以:   
别忘了加强你的密码，开启多点认证     
永远不要点可疑邮件    

## 接下来   
